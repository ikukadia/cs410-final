{"version":3,"file":"rect.js","sourceRoot":"","sources":["../../../../src/compile/mark/rect.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,QAAQ,EAAE,SAAS,EAAC,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAC,UAAU,EAAC,MAAM,kBAAkB,CAAC;AAC5C,OAAO,KAAK,GAAG,MAAM,WAAW,CAAC;AACjC,OAAO,EAAC,IAAI,EAAC,MAAM,YAAY,CAAC;AAChC,OAAO,EAAC,iBAAiB,EAAE,SAAS,EAAC,MAAM,aAAa,CAAC;AAIzD,OAAO,KAAK,MAAM,MAAM,UAAU,CAAC;AAEnC,MAAM,CAAC,MAAM,IAAI,GAAiB;IAChC,MAAM,EAAE,MAAM;IACd,WAAW,EAAE,CAAC,KAAgB,EAAE,EAAE;QAChC,yBACK,MAAM,CAAC,eAAe,CAAC,KAAK,EAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,QAAQ,EAAC,CAAC,EACjE,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,EACxB,YAAY,CAAC,KAAK,EAAE,GAAG,CAAC,EAC3B;IACJ,CAAC;CACF,CAAC;AAEF,MAAM,UAAU,YAAY,CAAC,KAAgB,EAAE,OAAkB;IAC/D,MAAM,QAAQ,GAAG,OAAO,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC;IAC/C,MAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;IACzC,MAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;IAC3C,MAAM,KAAK,GAAG,KAAK,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;IAC/C,MAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;IACxD,MAAM,SAAS,GAAG,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAE3C,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;QAC/E,OAAO,MAAM,CAAC,WAAW,CAAC;YACxB,QAAQ;YACR,SAAS;YACT,OAAO;YACP,IAAI,EAAE,MAAM;YACZ,SAAS;YACT,OAAO,EAAE,CAAC;YACV,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC;SAC9B,CAAC,CAAC;KACJ;SAAM,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,KAAK,IAAI,iBAAiB,CAAC,SAAS,CAAC,EAAE;QACxE,0BAA0B;QAC1B,IAAI,SAAS,KAAK,SAAS,CAAC,IAAI,EAAE;YAChC,OAAO,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;SACtD;aAAM;YACL,sDAAsD;YACtD,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC,OAAO,CAAC,wBAAwB,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC,CAAC;SACxE;KACF;SAAM;QACL,+BAA+B;QAC/B,yBACK,MAAM,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,EAAE,WAAW,CAAC,EACjD,MAAM,CAAC,cAAc,CAAC,KAAK,EAAE,WAAW,EAAE,QAAQ,CAAC,EACtD;KACH;AACH,CAAC","sourcesContent":["import {isBinned, isBinning} from '../../bin';\nimport {isFieldDef} from '../../channeldef';\nimport * as log from '../../log';\nimport {RECT} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {VgEncodeEntry} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\n\nexport const rect: MarkCompiler = {\n  vgMark: 'rect',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...rectPosition(model, 'x'),\n      ...rectPosition(model, 'y')\n    };\n  }\n};\n\nexport function rectPosition(model: UnitModel, channel: 'x' | 'y'): VgEncodeEntry {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.encoding[channel];\n  const fieldDef2 = model.encoding[channel2];\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const scaleName = model.scaleName(channel);\n\n  if (isFieldDef(fieldDef) && (isBinning(fieldDef.bin) || isBinned(fieldDef.bin))) {\n    return mixins.binPosition({\n      fieldDef,\n      fieldDef2,\n      channel,\n      mark: 'rect',\n      scaleName,\n      spacing: 0,\n      reverse: scale.get('reverse')\n    });\n  } else if (isFieldDef(fieldDef) && scale && hasDiscreteDomain(scaleType)) {\n    /* istanbul ignore else */\n    if (scaleType === ScaleType.BAND) {\n      return mixins.bandPosition(fieldDef, channel, model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, scaleType));\n    }\n  } else {\n    // continuous scale or no scale\n    return {\n      ...mixins.pointPosition(channel, model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', channel2)\n    };\n  }\n}\n"]}